// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: quiz.sql

package dbgen

import (
	"context"
	"database/sql"
)

const deleteQuiz = `-- name: DeleteQuiz :exec
DELETE FROM quizzes
WHERE
  id = ?
`

func (q *Queries) DeleteQuiz(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteQuiz, id)
	return err
}

const findLatestQuizzes = `-- name: FindLatestQuizzes :many
SELECT
  id, user_id, content, option_1, option_2, option_3, option_4, correct_num, explanation, created_at
FROM
  quizzes
ORDER BY id DESC
LIMIT ? OFFSET ?
`

type FindLatestQuizzesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) FindLatestQuizzes(ctx context.Context, arg FindLatestQuizzesParams) ([]Quiz, error) {
	rows, err := q.db.QueryContext(ctx, findLatestQuizzes, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Quiz{}
	for rows.Next() {
		var i Quiz
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Content,
			&i.Option1,
			&i.Option2,
			&i.Option3,
			&i.Option4,
			&i.CorrectNum,
			&i.Explanation,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findQuizByID = `-- name: FindQuizByID :one
SELECT
   id, user_id, content, option_1, option_2, option_3, option_4, correct_num, explanation, created_at
FROM
  quizzes
WHERE
  id = ?
`

func (q *Queries) FindQuizByID(ctx context.Context, id string) (Quiz, error) {
	row := q.db.QueryRowContext(ctx, findQuizByID, id)
	var i Quiz
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Content,
		&i.Option1,
		&i.Option2,
		&i.Option3,
		&i.Option4,
		&i.CorrectNum,
		&i.Explanation,
		&i.CreatedAt,
	)
	return i, err
}

const findQuizzesByUserID = `-- name: FindQuizzesByUserID :many
SELECT
   id, user_id, content, option_1, option_2, option_3, option_4, correct_num, explanation, created_at
FROM
  quizzes
WHERE
  user_id = ?
LIMIT ? OFFSET ?
`

type FindQuizzesByUserIDParams struct {
	UserID string `json:"user_id"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) FindQuizzesByUserID(ctx context.Context, arg FindQuizzesByUserIDParams) ([]Quiz, error) {
	rows, err := q.db.QueryContext(ctx, findQuizzesByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Quiz{}
	for rows.Next() {
		var i Quiz
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Content,
			&i.Option1,
			&i.Option2,
			&i.Option3,
			&i.Option4,
			&i.CorrectNum,
			&i.Explanation,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertQuiz = `-- name: InsertQuiz :exec
INSERT INTO
  quizzes (id, user_id, content, option_1, option_2, option_3, option_4, correct_num, explanation, created_at)
VALUES
  (
		?,
		?,
		?,
		?,
		?,
		?,
		?,
		?,
		?,
		NOW()
  )
`

type InsertQuizParams struct {
	ID          string         `json:"id"`
	UserID      string         `json:"user_id"`
	Content     string         `json:"content"`
	Option1     string         `json:"option_1"`
	Option2     string         `json:"option_2"`
	Option3     sql.NullString `json:"option_3"`
	Option4     sql.NullString `json:"option_4"`
	CorrectNum  int8           `json:"correct_num"`
	Explanation sql.NullString `json:"explanation"`
}

func (q *Queries) InsertQuiz(ctx context.Context, arg InsertQuizParams) error {
	_, err := q.db.ExecContext(ctx, insertQuiz,
		arg.ID,
		arg.UserID,
		arg.Content,
		arg.Option1,
		arg.Option2,
		arg.Option3,
		arg.Option4,
		arg.CorrectNum,
		arg.Explanation,
	)
	return err
}
